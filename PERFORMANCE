Tub needs to be blazing freakin' fast.

Sounds challenging... let's get to work!


Comparison with Git
===================

Although Git is a fast DVCS, Git isn't necessary a fast *database* in a general
sense.

In fact, as a rule of thumb, unless Tub is faster than Git as a DVCS for a given
operation, Tub probably isn't fast enough as a database.

For example, Git writes new objects in "loose" format, each object in its own
file.  A reasonable choice for a DVCS, but that's also 4 system calls to write
one small object:

    1. open()
    2. write()
    3. close()
    4. rename()

As Tub needs very fast small object read and write performance, the above
approach is too costly.

Tub writes new small objects with a single call to write(), which will append
the object to the append file.  The next step is to have Tub write all small
objects needed for a commit using vectored IO with a single call to pwritev(),
which will get us down to a fraction of a system call per small object write.
Much better.


Set Budgets
===========

We don't want to get lost in micro optimizations early on, that's not what we're
talking about.  But we need to consider macro optimizations, like minimizing
system calls and memory allocations.

For a given operation, set a budget for system calls and memory allocations.
If that budget isn't at the theoretical minimum, try to get it there... or have
a very good justification for going over budget.


Hashing Performance
===================

Like Git, Tub does a lot of hashing, so the performance of the hash function we
use is critical.  There seem to be two high-performance contenders: 

    1. Blake3 - https://github.com/BLAKE3-team/BLAKE3

    2. Kangaroo Twelve - https://keccak.team/kangarootwelve.html

The question is whether they are secure enough for a decently long run in the
protocol.

Blake3 already has a great Rust implementation (by the Blake3 developers!)

Kangaroo Twelve has hardware support (Sha3 ARMV8-A instructions), and K12 is
probably more likely to get hardware support in x86-64 CPU's (eventually).  But
Blake3 is faster and has less need for hardware support in the first place.


Storage Efficiency
==================

Document oriented databases aren't generally known for their storage efficiency,
which can limit where they can be used.

We want Tub to be the most storage efficient document oriented database on the
market.  Jason's current split schema design probably gets us there.


SIMD
====

Ah yes, that underutilized CPU resource.

The Rust SIMD module looks promising, although it's currently only enabled in
the nightly builds... this might be a reason to develop against the nightly
builds.

It would be cool if Tub was a "SIMD first" project, and we should think about
this when designing the protocols.

